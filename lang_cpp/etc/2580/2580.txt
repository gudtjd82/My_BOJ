i => box #
j => node # in the box

# row => (i/3) * 3 + j/3
i = 0,1,2	j = 0,1,2 	=> 0
		j = 3,4,5 	=> 1
		j = 6,7,8	=> 2

i = 3,4,5	j = 0,1,2	=> 3
		j = 3,4,5	=> 4
		j = 6,7,8	=> 5

# col	=> (i%3) *3 + (j%3)
i = 0,3,6	j = 0,3,6	=>0
		j = 1,4,7	=>1
		j = 2,5,8	=>2

i = 1,4,7	j = 0,3,6	=>3
		j = 1,4,7	=>4
		j = 2,5,8	=>5

i = 2,5,8	j = 0,3,6	=>6
		j = 1,4,7	=>7
		j = 2,5,8	=>8	

i = 3	

1. 칸을 하나씩 돌면서 빈칸이면 그 안에 들어갈 수 있는 숫자(가로, 세로, 박스 중복 제거) 집합 생성
2. 칸을 하나씩 돌며 다음을 수행 (숫자를 채운 후에는 가로, 세로, 박스에서 그 숫자 제거)
	2-1. 빈칸이고 들어갈 수 있는 숫자가 1개 뿐인 경우
		 -> 그 숫자를 채움.
	2-2. 빈칸이지만 들어갈 수 있는 숫자가 2개 이상인 경우
		 -> 가로, 세로, 박스에 다른 빈칸과 겹치는 수 
			제거
		 -> 제거 후 숫자가 1개이면 그 숫자 채움
	2-3. 제거 후에 숫자가 1이 아닌 경우
		 -> A = (해당 빈칸 집합) - (가로줄 빈칸들				    의 교집합)
		 -> n(A) > 0이면, A의 첫번째 원소를 채움
		 -> n(A) = 0이면, 해당 빈칸 집합의 첫번째 
			원소를 채움
3. 2번을 다 채울 때까지 반복.


0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0



0 0 0 7 5 0 0 3 0
1 0 6 0 0 0 0 0 0
8 0 0 3 0 0 0 0 0
0 2 0 0 0 0 0 4 0
0 0 0 6 0 0 8 0 0
0 0 0 0 0 1 0 0 0
0 4 0 0 9 0 0 0 0
3 0 0 0 4 0 0 0 0
0 0 0 0 0 0 1 0 0

5 7 9
5 9
7 9


0 7 6 0 0 0 9 0 0
0 8 0 1 9 5 7 6 0
0 0 9 7 6 4 0 0 3
0 0 0 0 0 6 0 3 7
0 0 0 0 8 7 5 1 6
5 6 7 3 0 0 0 0 9
7 1 0 6 2 0 0 9 0
0 0 0 0 7 0 6 0 0
6 9 0 0 4 0 3 7 0
-------------------------






Q)
2 0 0 0 0 0 0 7 4
0 0 0 5 0 1 0 0 0
8 0 0 0 0 0 0 0 0
0 3 0 6 0 0 1 0 0
4 0 0 0 2 0 0 0 0
0 7 0 0 0 0 0 0 0
0 0 0 0 4 0 0 8 0
0 0 1 0 0 0 5 0 0
0 6 0 0 0 0 0 0 0



---(2,7)의 가로 세로 박스---
(2, 2) => 4 9
(2, 3) => 3 4 7 9
(2, 5) => 3 7 8 9	
(2, 7) => 2 3 8 9
(2, 8) => 2 3 9
(2, 9) => 2 3 8 9
2, 3, 8
---------------------
(2, 7) => 2 3 8 9
(3, 7) => 2 3 6 9
(5, 7) => 3 6 7 8 9
(6, 7) => 2 3 4 6 8 9
(7, 7) => 2 3 6 7 9
(9, 7) => 2 3 4 7 9
2, 8
-----------------------
(1, 7) => 3 8 9
(2, 7) => 2 3 8 9
(2, 8) => 2 3 9
(2, 9) => 2 3 8 9
(3, 7) => 2 3 6 9
2, 8
------------------------
common = {2, 8}
combi = {2, 3, 8}
--------------------------
----(2,8)의 가로 세로 박스----
(2, 2) => 4 9
(2, 3) => 3 4 7 9
(2, 5) => 3 7 8 9
(2, 7) => 2 3 8 9
(2, 8) => 2 3 9
(2, 9) => 2 3 8 9
2
-------------------------
(2, 8) => 2 3 9
(4, 8) => 2 4 5 9
(5, 8) => 3 5 6 9
(6, 8) => 2 3 4 5 6 9
(8, 8) => 2 3 4 6 9
(9, 8) => 2 3 4 9
2, 3
--------------------------
(1, 7) => 3 8 9
(2, 7) => 2 3 8 9
(2, 8) => 2 3 9
(2, 9) => 2 3 8 9
(3, 7) => 2 3 6 9
2
------------------------
common = {2}
combi = {2, 3}






